name: Deploy to VPS

# Workflow triggers
on:
  push:
    branches: [main]
  workflow_dispatch:  # Allow manual triggering

# Global environment variables available to all jobs
env:
  NODE_VERSION: '22'  # Align with ci.yml minimum supported version
  PNPM_VERSION: '10.14.0'

# Concurrency settings to prevent multiple deployments
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false  # Don't cancel in-progress deployments

# Default settings for all jobs
defaults:
  run:
    shell: bash
    working-directory: .

# Job definitions with dependencies
jobs:
  # ========================================
  # DEPLOY JOB - Deploy to production VPS
  # ========================================
  deploy:
    name: Deploy to Production VPS
    runs-on: ubuntu-latest
    timeout-minutes: 15
    if: github.ref == 'refs/heads/main'

    permissions:
      contents: read
      deployments: write
      statuses: write

    environment:
      name: production
      # URL must be set as a static value or from non-secret sources
      # Using a placeholder that will be visible in GitHub UI
      url: https://api.oluwasetemi.dev

    outputs:
      # Outputs cannot use secrets directly
      deployment-status: ${{ steps.health-check.outcome }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for better analysis

      - name: Setup environment and build
        uses: ./.github/actions/build
        with:
          node-version: ${{ env.NODE_VERSION }}
          pnpm-version: ${{ env.PNPM_VERSION }}
          build-command: 'pnpm run build'

      - name: Setup SSH directory
        run: |
          mkdir -p $HOME/.ssh

      - name: Setup SSH for local testing (ACT)
        if: env.ACT == 'true'
        run: |
          echo "üß™ Setting up fake SSH for local testing with act"
          cat > $HOME/.ssh/deploy_key << 'EOF'
          -----BEGIN OPENSSH PRIVATE KEY-----
          fake-key-for-local-testing
          -----END OPENSSH PRIVATE KEY-----
          EOF
          echo "‚úÖ Fake SSH key created for local testing"

      - name: Add SSH key
        if: env.ACT != 'true'   # real runners only
        run: |
          # Check if the secret exists and has content
          if [ -z "${{ secrets.DEPLOY_SSH_KEY }}" ]; then
            echo "‚ùå DEPLOY_SSH_KEY secret is empty or not set"
            exit 1
          fi

          # Clean and prepare the SSH key(new)
          echo "${{ secrets.DEPLOY_SSH_KEY }}" | tr -d '\r' | sed '/^$/d' > $HOME/.ssh/deploy_key

          # Validate file was created and has content
          if [ ! -s $HOME/.ssh/deploy_key ]; then
            echo "‚ùå SSH key file is empty after processing"
            exit 1
          fi

          # Check file size (SSH keys should be substantial)
          KEY_SIZE=$(wc -c < $HOME/.ssh/deploy_key)
          if [ "$KEY_SIZE" -lt 100 ]; then
            echo "‚ùå SSH key file is too small ($KEY_SIZE bytes). Expected at least 100 bytes."
            echo "This suggests the secret content is invalid or truncated."
            exit 1
          fi

          # Ensure the key has proper SSH key format
          if ! grep -q "BEGIN.*PRIVATE KEY" $HOME/.ssh/deploy_key; then
            echo "‚ùå SSH key does not contain valid header (BEGIN PRIVATE KEY)"
            echo "File appears to contain: $(head -c 50 $HOME/.ssh/deploy_key | tr '\n' ' ')..."
            exit 1
          fi

          if ! grep -q "END.*PRIVATE KEY" $HOME/.ssh/deploy_key; then
            echo "‚ùå SSH key does not contain valid footer (END PRIVATE KEY)"
            exit 1
          fi

          echo "‚úÖ SSH key secret validation passed"

      - name: Configure SSH key permissions and setup agent
        if: env.ACT != 'true'   # Skip SSH agent setup in ACT mode
        run: |
          chmod 600 $HOME/.ssh/deploy_key

          # Validate SSH key format with detailed error output
          if ! ssh-keygen -l -f $HOME/.ssh/deploy_key 2>&1; then
            echo "‚ùå SSH key validation failed"
            echo "Key file contents (first/last lines for debugging):"
            head -2 $HOME/.ssh/deploy_key
            echo "..."
            tail -2 $HOME/.ssh/deploy_key
            exit 1
          fi

          # Setup SSH agent and export environment variables
          eval "$(ssh-agent -s)"
          echo "SSH_AUTH_SOCK=$SSH_AUTH_SOCK" >> $GITHUB_ENV
          echo "SSH_AGENT_PID=$SSH_AGENT_PID" >> $GITHUB_ENV
          ssh-add $HOME/.ssh/deploy_key

          echo "‚úÖ SSH key validated and added to agent successfully"

      - name: Setup SSH permissions for local testing (ACT)
        if: env.ACT == 'true'
        run: |
          echo "üß™ Setting up SSH permissions for local testing"
          chmod 600 $HOME/.ssh/deploy_key
          echo "‚úÖ SSH permissions configured for local testing"

      - name: Verify ssh-agent has key
        if: env.DEBUG_SSH == 'true' && env.ACT != 'true'
        run: |
          echo "üîç Verifying SSH agent has loaded the key..."
          ssh-add -l || (echo "‚ùå No keys found in ssh-agent" && exit 1)
          echo "‚úÖ SSH agent verification completed"

      - name: Verify fake SSH key for local testing
        if: env.DEBUG_SSH == 'true' && env.ACT == 'true'
        run: |
          echo "üß™ LOCAL TESTING - Verifying fake SSH key"
          if [ -f $HOME/.ssh/deploy_key ]; then
            echo "‚úÖ SSH key file exists at $HOME/.ssh/deploy_key"
            echo "‚úÖ Key permissions: $(ls -la $HOME/.ssh/deploy_key | awk '{print $1}')"
            echo "üìã Simulating 'ssh-add -l' output:"
            echo "2048 SHA256:fake-fingerprint-for-local-testing fake-key-for-local-testing (ED25519)"
          else
            echo "‚ùå SSH key file not found"
            exit 1
          fi

      - name: Configure SSH client
        if: env.ACT != 'true'
        run: |
          mkdir -p ~/.ssh
          cat >> ~/.ssh/config << EOF
          Host ${{ secrets.VPS_HOST }}
            HostName ${{ secrets.VPS_HOST }}
            User ${{ secrets.VPS_USER }}
            IdentityFile $HOME/.ssh/deploy_key
            IdentitiesOnly yes
            StrictHostKeyChecking no
            UserKnownHostsFile /dev/null
            ServerAliveInterval 60
            ServerAliveCountMax 3
            ConnectTimeout 30
            TCPKeepAlive yes
            Compression yes
          EOF
          chmod 600 ~/.ssh/config
          echo "‚úÖ SSH client configuration completed"

      - name: Add VPS to known hosts and test connection
        if: env.ACT != 'true'
        run: |
          # Add host to known hosts
          ssh-keyscan -H ${{ secrets.VPS_HOST }} >> ~/.ssh/known_hosts 2>/dev/null || echo "Warning: Could not add host key, using StrictHostKeyChecking=no"

          # Test SSH connection
          echo "üîç Testing SSH connection..."
          if ssh -o BatchMode=yes -o ConnectTimeout=30 ${{ secrets.VPS_HOST }} 'echo "‚úÖ SSH connection successful"'; then
            echo "‚úÖ SSH connection test passed"
          else
            echo "‚ùå SSH connection test failed"
            echo "üîç Debugging SSH connection..."
            ssh -vvv -o BatchMode=yes -o ConnectTimeout=30 ${{ secrets.VPS_HOST }} 'echo "Connection test"' 2>&1 || true
            exit 1
          fi

      - name: Mock deployment steps for local testing
        if: env.ACT == 'true'
        run: |
          echo "üß™ LOCAL TESTING MODE - Simulating deployment steps"
          echo "‚úÖ Would create backup on VPS"
          echo "‚úÖ Would sync files to VPS"
          echo "‚úÖ Would install dependencies on VPS"
          echo "‚úÖ Would run database migrations"
          echo "‚úÖ Would restart application"
          echo "‚úÖ Would run health check"
          echo "üéâ Local testing simulation completed successfully!"

      - name: Create backup on VPS
        if: env.ACT != 'true'
        run: |
          ssh ${{ secrets.VPS_HOST }} "
            if [ -d '${{ secrets.DEPLOY_PATH }}' ]; then
              cd ${{ secrets.DEPLOY_PATH }}/.. &&
              echo \"üì¶ Creating backup with database preservation...\"

              # Create backup directory
              BACKUP_NAME=\"backup-\$(date +%Y%m%d-%H%M%S)\"
              cp -r '${{ secrets.DEPLOY_PATH }}' \"\$BACKUP_NAME\"

              # Preserve database files if they exist
              if [ -f '${{ secrets.DEPLOY_PATH }}/prod.db' ]; then
                echo \"üíæ Preserving prod.db in backup\"
                cp '${{ secrets.DEPLOY_PATH }}/prod.db' \"\$BACKUP_NAME/prod.db\"
              fi

              if [ -f '${{ secrets.DEPLOY_PATH }}/dev.db' ]; then
                echo \"üíæ Preserving dev.db in backup\"
                cp '${{ secrets.DEPLOY_PATH }}/dev.db' \"\$BACKUP_NAME/dev.db\"
              fi

              echo \"‚úÖ Backup created: \$BACKUP_NAME\"
            else
              echo 'No existing deployment directory to backup'
            fi
          "

      - name: Deploy to VPS
        if: env.ACT != 'true'
        run: |
          ssh ${{ secrets.VPS_HOST }} "mkdir -p ${{ secrets.DEPLOY_PATH }}"
          ssh ${{ secrets.VPS_HOST }} "pm2 stop api.oluwasetemi.dev || true"

          # Preserve existing database files before deployment
          ssh ${{ secrets.VPS_HOST }} "
            if [ -f '${{ secrets.DEPLOY_PATH }}/prod.db' ]; then
              echo \"üíæ Preserving existing prod.db\"
              cp '${{ secrets.DEPLOY_PATH }}/prod.db' '/tmp/prod.db.backup'
            fi
            if [ -f '${{ secrets.DEPLOY_PATH }}/dev.db' ]; then
              echo \"üíæ Preserving existing dev.db\"
              cp '${{ secrets.DEPLOY_PATH }}/dev.db' '/tmp/dev.db.backup'
            fi
          "

                    # Deploy using git pull
          ssh ${{ secrets.VPS_HOST }} "
            cd '${{ secrets.DEPLOY_PATH }}'

            # Configure git to use SSH with deploy key
            export GIT_SSH_COMMAND='ssh -i ~/.ssh/id_ed25519_api.oluwasetemi.dev -o IdentitiesOnly=yes'

            # Initialize git repository if it doesn't exist
            if [ ! -d '.git' ]; then
              echo \"üîß Initializing git repository\"
              git init
              git remote add origin git@github.com:oluwasetemi/api.oluwasetemi.dev.git
            fi

            # Fetch latest changes
            echo \"üì• Fetching latest changes from GitHub\"
            git fetch origin main

            # Reset to latest commit (this will update all files)
            echo \"üîÑ Updating to latest commit\"
            git reset --hard origin/main

            # Clean untracked files (but preserve .env and database files)
            echo \"üßπ Cleaning untracked files\"
            git clean -fd
          "

          # Restore database files after deployment
          ssh ${{ secrets.VPS_HOST }} "
            if [ -f '/tmp/prod.db.backup' ]; then
              echo \"üíæ Restoring prod.db\"
              cp '/tmp/prod.db.backup' '${{ secrets.DEPLOY_PATH }}/prod.db'
              rm '/tmp/prod.db.backup'
            fi
            if [ -f '/tmp/dev.db.backup' ]; then
              echo \"üíæ Restoring dev.db\"
              cp '/tmp/dev.db.backup' '${{ secrets.DEPLOY_PATH }}/dev.db'
              rm '/tmp/dev.db.backup'
            fi
          "

          ssh ${{ secrets.VPS_HOST }} "cd ${{ secrets.DEPLOY_PATH }} && pnpm install"
          ssh ${{ secrets.VPS_HOST }} "cd ${{ secrets.DEPLOY_PATH }} && (pnpm run db:migrate && pnpm run db:generate) || echo 'No database operations needed'"
          ssh ${{ secrets.VPS_HOST }} "cd ${{ secrets.DEPLOY_PATH }} && pm2 start ecosystem.config.cjs || pm2 restart api.oluwasetemi.dev"
          ssh ${{ secrets.VPS_HOST }} "pm2 save"

      - name: Health Check with Retry
        id: health-check
        if: env.ACT != 'true'
        run: |
          echo "Waiting for application to start..."
          sleep 30
          for i in {1..5}; do
            if curl -f --connect-timeout 10 --max-time 30 ${{ secrets.APP_URL }}; then
              echo "‚úÖ Deployment successful!"
              exit 0
            else
              echo "Health check attempt $i failed, retrying in 10 seconds..."
              sleep 10
            fi
          done
          echo "‚ùå Health check failed after 5 attempts"
          exit 1

      - name: Rollback on Failure
        if: failure() && env.ACT != 'true'
        run: |
          echo "üîÑ Rolling back due to deployment failure..."
          ssh ${{ secrets.VPS_HOST }} "
            set -e
            DEPLOY_PATH='${{ secrets.DEPLOY_PATH }}'
            DEPLOY_PARENT=\$(dirname \"\$DEPLOY_PATH\")

            echo \"üîç Looking for backups in: \$DEPLOY_PARENT\"
            echo \"üîç Current directory: \$(pwd)\"
            echo \"üîç Available backups:\"
            ls -la backup-* 2>/dev/null || echo \"No backup-* files found in current directory\"

            cd \"\$DEPLOY_PARENT\"
            echo \"üîç Looking for backups in parent directory: \$(pwd)\"
            echo \"üîç Available backups in parent:\"
            ls -la backup-* 2>/dev/null || echo \"No backup-* files found in parent directory\"

            LATEST_BACKUP=\$(ls -t backup-* 2>/dev/null | head -n1)
            echo \"üîç Latest backup found: \$LATEST_BACKUP\"

            if [ -n \"\$LATEST_BACKUP\" ] && [ -d \"\$LATEST_BACKUP\" ]; then
              echo \"‚úÖ Found valid backup: \$LATEST_BACKUP\"

              # Preserve current database files before rollback
              if [ -d \"\$DEPLOY_PATH\" ]; then
                echo \"üíæ Preserving current database files before rollback\"
                if [ -f \"\$DEPLOY_PATH/prod.db\" ]; then
                  cp \"\$DEPLOY_PATH/prod.db\" \"/tmp/prod.db.current\"
                fi
                if [ -f \"\$DEPLOY_PATH/dev.db\" ]; then
                  cp \"\$DEPLOY_PATH/dev.db\" \"/tmp/dev.db.current\"
                fi
                echo \"üóëÔ∏è Removing current deployment directory\"
                rm -rf \"\$DEPLOY_PATH\"
              fi

              echo \"üîÑ Restoring from backup: \$LATEST_BACKUP\"
              mv \"\$LATEST_BACKUP\" \"\$DEPLOY_PATH\" &&
              cd \"\$DEPLOY_PATH\" &&

              # Restore current database files (they might be more recent than backup)
              if [ -f \"/tmp/prod.db.current\" ]; then
                echo \"üíæ Restoring current prod.db (preserving latest data)\"
                cp \"/tmp/prod.db.current\" \"\$DEPLOY_PATH/prod.db\"
                rm \"/tmp/prod.db.current\"
              fi
              if [ -f \"/tmp/dev.db.current\" ]; then
                echo \"üíæ Restoring current dev.db (preserving latest data)\"
                cp \"/tmp/dev.db.current\" \"\$DEPLOY_PATH/dev.db\"
                rm \"/tmp/dev.db.current\"
              fi

              echo \"üöÄ Restarting application\"
              pm2 restart api.oluwasetemi.dev &&
              echo '‚úÖ Rollback completed successfully'
            else
              echo '‚ùå No valid backup found for rollback'
              echo \"üîç Debugging: Checking if any backup directories exist\"
              find . -name \"backup-*\" -type d 2>/dev/null || echo \"No backup directories found anywhere\"
              exit 1
            fi
          "

      - name: Cleanup old backups
        if: success() && env.ACT != 'true'
        run: |
          ssh ${{ secrets.VPS_HOST }} "
            set -e
            DEPLOY_PATH='${{ secrets.DEPLOY_PATH }}'
            DEPLOY_PARENT=\$(dirname \"\$DEPLOY_PATH\")

            echo \"üßπ Starting backup cleanup...\"
            cd \"\$DEPLOY_PARENT\"
            echo \"üîç Looking for backups in: \$(pwd)\"

            # List all backups
            echo \"üìã All available backups:\"
            ls -la backup-* 2>/dev/null || echo \"No backup-* files found\"

            # Count total backup directories (not files)
            BACKUP_COUNT=\$(find . -maxdepth 1 -type d -name \"backup-*\" | wc -l)
            echo \"üìä Total backup directories found: \$BACKUP_COUNT\"

            if [ \"\$BACKUP_COUNT\" -gt 2 ]; then
              echo \"üóëÔ∏è Cleaning up old backups (keeping latest 2)...\"
              # Get list of backup directories to delete (all except the 2 most recent)
              BACKUPS_TO_DELETE=\$(find . -maxdepth 1 -type d -name \"backup-*\" -printf \"%T@ %p\\n\" | sort -nr | tail -n +\$((BACKUP_COUNT - 1)) | cut -d' ' -f2-)

              if [ -n \"\$BACKUPS_TO_DELETE\" ]; then
                echo \"üóëÔ∏è Backup directories to delete:\"
                echo \"\$BACKUPS_TO_DELETE\" | while read backup; do
                  echo \"  - \$backup\"
                done

                # Delete old backup directories
                echo \"\$BACKUPS_TO_DELETE\" | xargs -r rm -rf
                echo \"‚úÖ Cleanup completed successfully\"
              else
                echo \"‚ÑπÔ∏è No backup directories to delete\"
              fi
            else
              echo \"‚ÑπÔ∏è Only \$BACKUP_COUNT backup directories found, keeping all (minimum 2)\"
            fi

            # Show remaining backups
            echo \"üìã Remaining backups:\"
            ls -la backup-* 2>/dev/null || echo \"No backups remaining\"
          "

      - name: Notify deployment success
        if: success() && env.ACT != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const deploymentUrl = 'https://api.oluwasetemi.dev';
            const commit = context.sha.substring(0, 7);
            
            github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: context.sha,
              state: 'success',
              target_url: deploymentUrl,
              description: `Deployed successfully to ${deploymentUrl}`,
              context: 'deployment/vps'
            });

      - name: Notify deployment failure
        if: failure() && env.ACT != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: context.sha,
              state: 'failure',
              description: 'Deployment failed - check logs',
              context: 'deployment/vps'
            });
